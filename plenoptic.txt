// -*- c -*-

precision highp float;

varying vec2 vtex_coord;

uniform sampler2D tex;
uniform highp float num_micro_images_x, num_micro_images_y;
uniform highp float pitch;
uniform highp float view_x, view_y;
uniform highp float aperture;

/**
   This function basically does the 4D lightfield lookup.
 */
vec4 micro_image_sample(vec2 micro_image, vec2 offset) {
    vec2 num_micro_images = vec2(num_micro_images_x, num_micro_images_y);

    // for now just do nearest interpolation
    return texture2D(tex, (micro_image + offset) / num_micro_images);
}

void main() {
    //const float view_x = 0.5, view_y = 0.6, pitch = 0.1094;
    const float radius = 1.0;
    vec2 view_shift = vec2(view_x, view_y);
    vec2 num_micro_images = vec2(num_micro_images_x, num_micro_images_y);
    vec2 micro_image = vtex_coord * num_micro_images;
    vec2 offset = micro_image - floor(micro_image) - view_shift;
    micro_image = floor(micro_image) + view_shift;

    float total_weight = 0.0;

    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);

    for(float i = -radius; i <= radius; i += 1.0) {
        for(float j = -radius; j <= radius; j += 1.0) {
            vec2 shift = vec2(i, j);
            vec2 interp = shift - floor(shift);
            
            vec2 lf_off = - pitch * (offset - shift);
            float weight = exp2(-aperture * dot(shift, shift));

            gl_FragColor += weight * micro_image_sample(micro_image + shift,
                                                        lf_off);
            total_weight += weight;
        }
    }

    gl_FragColor /= total_weight;
}
